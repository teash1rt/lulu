import{_ as a,o as e,c as o,Q as d}from"./chunks/framework.58d95b75.js";const _=JSON.parse('{"title":"待办","description":"","frontmatter":{},"headers":[],"relativePath":"info/todo.md","filePath":"info/todo.md"}'),r={name:"info/todo.md"},t=d('<h1 id="待办" tabindex="-1">待办 <a class="header-anchor" href="#待办" aria-label="Permalink to &quot;待办&quot;">​</a></h1><p>目前项目与我的预期间有很大的差距，仍有大量的工作需要完成</p><h2 id="消息系统" tabindex="-1">消息系统 <a class="header-anchor" href="#消息系统" aria-label="Permalink to &quot;消息系统&quot;">​</a></h2><p>之后会为<code>lulu</code>提供消息系统用于显示各种提示和警告信息</p><p>方案A是直接使用组件库的<code>message</code>或<code>notification</code>，方案B即自行实现</p><h2 id="替代unwrap" tabindex="-1">替代<code>unwrap</code> <a class="header-anchor" href="#替代unwrap" aria-label="Permalink to &quot;替代`unwrap`&quot;">​</a></h2><p>目前<code>rust</code>后端大量使用<code>unwrap</code>而并没有做错误的处理，这会导致在某些操作后由于错误直接退出程序，这是很不合适的</p><p>这个问题在最开始就遇到了，但是由于考虑到消息系统没有完成暂时没有做处理，后面会使用<code>Result</code>类型搭配消息系统解决这个问题</p><h2 id="代码执行" tabindex="-1">代码执行 <a class="header-anchor" href="#代码执行" aria-label="Permalink to &quot;代码执行&quot;">​</a></h2><p>目前代码执行是通过用户计算机的<code>node -e</code>命令直接运行代码，但这会导致一个问题，即在异步时无法实现即时输出</p><p>解决这个问题我目前想到的方案是新开线程并监听捕获输出，通过<code>emit</code>发送给前端，但这涉及到较为深入的<code>rust</code>编程知识，我现在还不太会</p><h2 id="markdown分屏显示" tabindex="-1"><code>markdown</code>分屏显示 <a class="header-anchor" href="#markdown分屏显示" aria-label="Permalink to &quot;`markdown`分屏显示&quot;">​</a></h2><p>分屏显示之后会通过改动<code>markdown-it</code>的解析方式，并通过匹配行号的方式实现</p><h2 id="markdown编辑补全" tabindex="-1"><code>markdown</code>编辑补全 <a class="header-anchor" href="#markdown编辑补全" aria-label="Permalink to &quot;`markdown`编辑补全&quot;">​</a></h2><p>目前编辑补全是手动实现的，在某些情况下存在问题和不合理的地方</p><h2 id="markdown目录跳转" tabindex="-1"><code>markdown</code>目录跳转 <a class="header-anchor" href="#markdown目录跳转" aria-label="Permalink to &quot;`markdown`目录跳转&quot;">​</a></h2><p>目前目录只能在<code>视图模式</code>下跳转，之后会对<code>编辑模式</code>进行兼容</p><h2 id="文件目录树的状态保持" tabindex="-1">文件目录树的状态保持 <a class="header-anchor" href="#文件目录树的状态保持" aria-label="Permalink to &quot;文件目录树的状态保持&quot;">​</a></h2><p>在新建文件和文件夹后目录树会重新加载，由于重新计算了<code>uuid</code>，新建前打开的文件目录无法保持</p><p>之后也许可以通过记录路径名而不是<code>uuid</code>的方式解决这个问题</p>',20),c=[t];function n(i,h,l,s,p,u){return e(),o("div",null,c)}const k=a(r,[["render",n]]);export{_ as __pageData,k as default};
